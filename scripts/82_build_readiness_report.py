#!/usr/bin/env python3

from __future__ import annotations

import argparse
import csv
from collections import defaultdict
from dataclasses import dataclass
from decimal import Decimal, InvalidOperation
from pathlib import Path

from _lib import DB_PATH, PROJECT_ROOT, FiscalYear, connect_db, fiscal_years_from_manifest, load_manifest


@dataclass(frozen=True)
class TbLine:
    fy: str
    account_code: str
    account_name: str
    account_type: str
    gifi_code: str
    debit: float
    credit: float
    net_cents: int


def load_tb(path: Path) -> list[TbLine]:
    rows = list(csv.DictReader(path.open()))
    out: list[TbLine] = []
    for r in rows:
        out.append(
            TbLine(
                fy=str(r["fy"]),
                account_code=str(r["account_code"]),
                account_name=str(r["account_name"]),
                account_type=str(r["account_type"]),
                gifi_code=str(r.get("gifi_code") or ""),
                debit=float(r["debit"] or 0),
                credit=float(r["credit"] or 0),
                net_cents=int(r["net_cents"] or 0),
            )
        )
    return out


def cents_to_dollars(cents: int) -> str:
    return f"{cents / 100:.2f}"

def dollars_to_cents(d: str | None) -> int:
    if d is None:
        return 0
    try:
        v = Decimal(str(d).strip() or "0")
    except (InvalidOperation, ValueError):
        return 0
    return int((v * 100).to_integral_value())


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--db", type=Path, default=DB_PATH)
    ap.add_argument("--out-dir", type=Path, default=PROJECT_ROOT / "output")
    args = ap.parse_args()

    manifest = load_manifest()
    fys = fiscal_years_from_manifest(manifest)
    if not fys:
        raise SystemExit("No fiscal_years found in manifest/sources.yml")

    args.out_dir.mkdir(parents=True, exist_ok=True)
    out_md = args.out_dir / "readiness_report.md"

    # Load TBs generated by scripts/80_build_trial_balance.py
    tb_by_fy: dict[str, list[TbLine]] = {}
    for fy in fys:
        tb_path = args.out_dir / f"trial_balance_{fy.fy}.csv"
        if not tb_path.exists():
            raise SystemExit(f"Missing {tb_path}. Run: python3 scripts/80_build_trial_balance.py")
        tb_by_fy[fy.fy] = load_tb(tb_path)

    # Bank coverage check + split-CC coverage checks (needs DB).
    conn = connect_db(args.db)
    try:
        scope_start = min(fy.start_date for fy in fys)
        scope_end = max(fy.end_date for fy in fys)
        bank_total = int(
            conn.execute(
                "select count(*) c from fresher_debits__bank_transactions where txn_date>=? and txn_date<=?",
                (scope_start, scope_end),
            ).fetchone()["c"]
        )
        bank_missing = int(
            conn.execute(
                """
                select count(*) c
                from fresher_debits__bank_transactions bt
                where bt.txn_date>=? and bt.txn_date<=?
                  and not exists (
                    select 1 from journal_entries je where je.source_bank_line_id = cast(bt.id as text)
                  )
                """,
                (scope_start, scope_end),
            ).fetchone()["c"]
        )
        bank_dupes = int(
            conn.execute(
                """
                select count(*) c from (
                  select source_bank_line_id, count(*) cnt
                  from journal_entries
                  where source_bank_line_id is not null
                    and entry_date>=? and entry_date<=?
                  group by source_bank_line_id
                  having cnt>1
                )
                """,
                (scope_start, scope_end),
            ).fetchone()["c"]
        )

        # Split CC coverage: compare split CC amounts vs CC settlement credits.
        split_cc_rows = conn.execute(
            """
            SELECT sp.wave_bill_id,
                   SUM(CAST(sp.amount_cents AS INTEGER)) AS split_cc_cents,
                   wb.invoice_date,
                   wb.vendor_raw
            FROM fresher_debits__split_payments sp
            JOIN wave_bills wb ON wb.id = CAST(sp.wave_bill_id AS INTEGER)
            WHERE sp.txn_type = 'CC'
              AND wb.invoice_date BETWEEN ? AND ?
            GROUP BY sp.wave_bill_id, wb.invoice_date, wb.vendor_raw
            """
        , (scope_start, scope_end)).fetchall()

        settlement_by_bill = {
            str(r["wave_bill_id"]): int(r["credit_cents"] or 0)
            for r in conn.execute(
                """
                SELECT je.source_record_id AS wave_bill_id,
                       SUM(CAST(jel.credit_cents AS INTEGER)) AS credit_cents
                FROM journal_entries je
                JOIN journal_entry_lines jel ON jel.journal_entry_id = je.id
                WHERE je.source_record_type = 'wave_bill_cc_settlement'
                  AND jel.account_code = '2410'
                GROUP BY je.source_record_id
                """
            ).fetchall()
        }

        split_cc_summary = []
        split_cc_missing = []
        split_cc_over = []
        for r in split_cc_rows:
            bill_id = str(r["wave_bill_id"])
            split_cents = int(r["split_cc_cents"] or 0)
            settled_cents = int(settlement_by_bill.get(bill_id, 0))
            diff = settled_cents - split_cents
            split_cc_summary.append(
                {
                    "wave_bill_id": bill_id,
                    "invoice_date": str(r["invoice_date"] or ""),
                    "vendor_raw": str(r["vendor_raw"] or ""),
                    "split_cc_cents": split_cents,
                    "settled_cents": settled_cents,
                    "diff_cents": diff,
                }
            )
            if diff < 0:
                split_cc_missing.append({**split_cc_summary[-1], "missing_cents": -diff})
            elif diff > 0:
                split_cc_over.append({**split_cc_summary[-1], "over_cents": diff})

        # CC payment linkage coverage (audit): CC payments with no supporting link to any Wave bill.
        cc_payment_bank_ids = {
            str(r["bank_txn_id"]).strip()
            for r in conn.execute(
                """
                SELECT DISTINCT bank_txn_id
                FROM fresher_debits__cc_payment_links
                WHERE bank_txn_id IS NOT NULL AND TRIM(bank_txn_id) <> ''
                """
            ).fetchall()
            if str(r["bank_txn_id"] or "").strip()
        }
        linked_cc_payment_bank_ids: set[str] = set()
        linked_cc_payment_bank_ids.update(
            str(r["bank_txn_id"]).strip()
            for r in conn.execute(
                """
                SELECT DISTINCT bank_txn_id
                FROM fresher_debits__wave_matches
                WHERE match_type='CC_PAYMENT_TRANSFER'
                  AND bank_txn_id IS NOT NULL AND TRIM(bank_txn_id) <> ''
                """
            ).fetchall()
            if str(r["bank_txn_id"] or "").strip()
        )
        linked_cc_payment_bank_ids.update(
            str(r["bank_txn_id"]).strip()
            for r in conn.execute(
                """
                SELECT DISTINCT bank_txn_id
                FROM fresher_debits__bank_allocations
                WHERE target_type='WAVE_BILL'
                  AND bank_txn_id IS NOT NULL AND TRIM(bank_txn_id) <> ''
                  AND target_id IS NOT NULL AND TRIM(target_id) <> ''
                """
            ).fetchall()
            if str(r["bank_txn_id"] or "").strip()
        )
        linked_cc_payment_bank_ids.update(
            str(r["bank_txn_id"]).strip()
            for r in conn.execute(
                """
                SELECT DISTINCT bank_txn_id
                FROM fresher_debits__wave_bill_funding
                WHERE bank_txn_id IS NOT NULL AND TRIM(bank_txn_id) <> ''
                """
            ).fetchall()
            if str(r["bank_txn_id"] or "").strip()
        )
        linked_cc_payment_bank_ids.update(
            str(r["txn_id"]).strip()
            for r in conn.execute(
                """
                SELECT DISTINCT txn_id
                FROM fresher_debits__split_payments
                WHERE txn_type='BANK'
                  AND txn_id IS NOT NULL AND TRIM(txn_id) <> ''
                """
            ).fetchall()
            if str(r["txn_id"] or "").strip()
        )
        linked_cc_payment_bank_ids.update(
            str(r["cc_payment_txn_id"]).strip()
            for r in conn.execute(
                """
                SELECT DISTINCT cc_payment_txn_id
                FROM fresher_debits__wave_matches
                WHERE cc_payment_txn_id IS NOT NULL AND TRIM(cc_payment_txn_id) <> ''
                """
            ).fetchall()
            if str(r["cc_payment_txn_id"] or "").strip()
        )
        unlinked_cc_payment_rows = conn.execute(
            """
            SELECT id, txn_date, CAST(debit_cents AS INTEGER) AS debit_cents
            FROM fresher_debits__bank_transactions
            WHERE used='1'
              AND txn_type='CC_PAYMENT'
              AND txn_date BETWEEN ? AND ?
              AND CAST(debit_cents AS INTEGER) > 0
              AND id IN (SELECT DISTINCT bank_txn_id FROM fresher_debits__cc_payment_links)
            """,
            (scope_start, scope_end),
        ).fetchall()
        unlinked_cc_payment_count = 0
        unlinked_cc_payment_total = 0
        unlinked_cc_payment_by_fy: dict[str, int] = defaultdict(int)
        for r in unlinked_cc_payment_rows:
            bank_txn_id = str(r["id"])
            if bank_txn_id not in cc_payment_bank_ids:
                continue
            if bank_txn_id in linked_cc_payment_bank_ids:
                continue
            unlinked_cc_payment_count += 1
            cents = int(r["debit_cents"] or 0)
            unlinked_cc_payment_total += cents
            d = str(r["txn_date"] or "")
            for fy in fys:
                if fy.start_date <= d <= fy.end_date:
                    unlinked_cc_payment_by_fy[fy.fy] += cents
                    break
    finally:
        conn.close()

    # Load wave mismatch detail outputs (produced by scripts/71_build_wave_bill_payment_journals.py)
    wave_pay_detail_path = args.out_dir / "wave_bill_payment_journal_detail.csv"
    wave_pay_rows = list(csv.DictReader(wave_pay_detail_path.open())) if wave_pay_detail_path.exists() else []
    wave_pay_mismatch = [r for r in wave_pay_rows if int(r.get("diff_cents") or 0) != 0]
    wave_pay_mismatch_total = sum(int(r["diff_cents"]) for r in wave_pay_mismatch) if wave_pay_mismatch else 0

    # Load wave reimbursement detail outputs (produced by scripts/77_build_wave_bill_reimbursement_journals.py)
    wave_reimb_detail_path = args.out_dir / "wave_bill_reimbursement_journal_detail.csv"
    wave_reimb_rows = list(csv.DictReader(wave_reimb_detail_path.open())) if wave_reimb_detail_path.exists() else []
    wave_reimb_scaled = sum(1 for r in wave_reimb_rows if str(r.get("allocation_scaled") or "") == "1")
    wave_reimb_remainder_total = sum(int(r.get("remainder_cents") or 0) for r in wave_reimb_rows) if wave_reimb_rows else 0

    # Load wave bill CC settlement detail outputs (produced by scripts/78_build_wave_bill_cc_settlement_journals.py)
    wave_cc_detail_path = args.out_dir / "wave_bill_cc_settlement_journal_detail.csv"
    wave_cc_rows = list(csv.DictReader(wave_cc_detail_path.open())) if wave_cc_detail_path.exists() else []
    wave_cc_total_cents = (
        sum(int(r.get("settlement_amount_cents") or r.get("bill_total_cents") or 0) for r in wave_cc_rows)
        if wave_cc_rows
        else 0
    )

    # Load bank debit detail outputs (produced by scripts/75_build_bank_debit_journals.py)
    bank_debit_detail_path = args.out_dir / "bank_debit_journal_detail.csv"
    bank_debit_rows = list(csv.DictReader(bank_debit_detail_path.open())) if bank_debit_detail_path.exists() else []
    due_from_by_reason: dict[str, int] = defaultdict(int)
    for r in bank_debit_rows:
        if str(r.get("debit_account") or "") != "2500":
            continue
        due_from_by_reason[str(r.get("debit_reason") or "")] += int(r.get("amount_cents") or 0)

    # Optional: include non-bank adjustments that affect due-from-shareholder (e.g., mileage fuel netting).
    due_from_non_bank_by_source: dict[str, int] = defaultdict(int)
    due_from_breakdown_path = args.out_dir / "due_from_shareholder_breakdown.csv"
    if due_from_breakdown_path.exists():
        for r in csv.DictReader(due_from_breakdown_path.open()):
            src = str(r.get("source_record_type") or "").strip()
            if src in ("bank_debits", "bank_inflows"):
                continue
            debit_cents = dollars_to_cents(r.get("debit"))
            credit_cents = dollars_to_cents(r.get("credit"))
            due_from_non_bank_by_source[src] += (debit_cents - credit_cents)

    with out_md.open("w", encoding="utf-8") as f:
        f.write("# Readiness report (T2 FY2024/FY2025)\n\n")
        f.write("This is a snapshot-style status report intended to highlight what is complete, and what still needs a conscious decision.\n\n")

        f.write("## Bank coverage (hard requirement)\n\n")
        f.write(f"- Bank txns in scope: {bank_total}\n")
        f.write(f"- Missing journalized bank lines: {bank_missing}\n")
        f.write(f"- Duplicate bank journal lines: {bank_dupes}\n\n")

        f.write("## Trial balance highlights\n\n")
        for fy in fys:
            tb = tb_by_fy.get(fy.fy) or []
            by_code = {r.account_code: r for r in tb}

            def amt(code: str) -> tuple[str, int]:
                r = by_code.get(code)
                if not r:
                    return ("0.00", 0)
                return (f"{abs(r.net_cents) / 100:.2f}", r.net_cents)

            revenue = sum(r.net_cents for r in tb if r.account_type == "revenue")
            expense = sum(r.net_cents for r in tb if r.account_type == "expense")
            net_income_cents = -(revenue + expense)

            f.write(f"### {fy.fy} ({fy.start_date} → {fy.end_date})\n\n")
            f.write(f"- Net income: ${cents_to_dollars(net_income_cents)}\n")
            f.write(f"- Cash (1000+1070): ${cents_to_dollars(by_code.get('1000', TbLine('', '', '', '', '', 0, 0, 0)).net_cents + by_code.get('1070', TbLine('', '', '', '', '', 0, 0, 0)).net_cents)}\n")
            f.write(f"- Accounts payable (2000): ${amt('2000')[0]} ({'CR' if amt('2000')[1] < 0 else 'DR'})\n")
            f.write(f"- Due to shareholder Thomas (2400): ${amt('2400')[0]} ({'CR' if amt('2400')[1] < 0 else 'DR'})\n")
            f.write(f"- Due to shareholder Dwayne (2410): ${amt('2410')[0]} ({'CR' if amt('2410')[1] < 0 else 'DR'})\n")
            f.write(f"- Due from shareholder (2500): ${amt('2500')[0]} ({'DR' if amt('2500')[1] > 0 else 'CR'})\n\n")

        f.write("## Wave bill payments (direct vendor payments)\n\n")
        f.write(f"- Posted entries: {len(wave_pay_rows)}\n")
        f.write(f"- Mismatches (bank != matched bill totals): {len(wave_pay_mismatch)}\n")
        if wave_pay_mismatch:
            f.write(f"- Net mismatch cents (sum diff_cents): {wave_pay_mismatch_total} (${cents_to_dollars(wave_pay_mismatch_total)})\n")
            # Show top 10 mismatches by abs diff.
            mism_sorted = sorted(wave_pay_mismatch, key=lambda r: abs(int(r.get("diff_cents") or 0)), reverse=True)
            f.write("\nTop mismatches (by absolute diff):\n\n")
            for r in mism_sorted[:10]:
                diff = int(r.get("diff_cents") or 0)
                f.write(
                    f"- bank_txn_id {r.get('bank_txn_id')} on {r.get('bank_date')}: "
                    f"bank ${cents_to_dollars(int(r.get('bank_debit_cents') or 0))} vs "
                    f"bills ${cents_to_dollars(int(r.get('matched_bill_total_cents') or 0))} "
                    f"(diff ${cents_to_dollars(diff)})\n"
                )
        f.write("\n")

        f.write("## Wave bills reimbursed to shareholders (AP → due-to-shareholder reclass)\n\n")
        f.write(f"- Posted reclass entries: {len(wave_reimb_rows)}\n")
        f.write(f"- Allocations auto-scaled (explicit splits over-allocated): {wave_reimb_scaled}\n")
        f.write(f"- Net remainder cents (bank - bill allocations): {wave_reimb_remainder_total} (${cents_to_dollars(wave_reimb_remainder_total)})\n")
        f.write("- Detail: `output/wave_bill_reimbursement_journal_detail.csv`\n\n")

        f.write("## Wave bills paid by credit card (AP → due-to-shareholder reclass)\n\n")
        f.write(f"- Posted reclass entries: {len(wave_cc_rows)}\n")
        f.write(
            f"- Total reclass cents (sum settlement amounts): {wave_cc_total_cents} (${cents_to_dollars(wave_cc_total_cents)})\n"
        )
        f.write(
            f"- Unlinked bank CC payments (no Wave bill link evidence): {unlinked_cc_payment_count} "
            f"totaling ${cents_to_dollars(unlinked_cc_payment_total)}\n"
        )
        if unlinked_cc_payment_by_fy:
            parts = ", ".join(f"{fy.fy} ${cents_to_dollars(unlinked_cc_payment_by_fy[fy.fy])}" for fy in fys)
            f.write(f"  - By FY: {parts}\n")
        f.write("- Detail: `output/wave_bill_cc_settlement_journal_detail.csv`\n\n")

        # Split CC coverage summary (guardrail)
        split_total = sum(int(r["split_cc_cents"] or 0) for r in split_cc_summary)
        f.write("## Split CC coverage (guardrail)\n\n")
        f.write(f"- Split CC bills in scope: {len(split_cc_summary)}\n")
        f.write(f"- Split CC total cents: {split_total} (${cents_to_dollars(split_total)})\n")
        f.write(f"- Under‑settled split CC bills: {len(split_cc_missing)}\n")
        if split_cc_missing:
            missing_total = sum(int(r["missing_cents"] or 0) for r in split_cc_missing)
            f.write(f"- Total missing cents: {missing_total} (${cents_to_dollars(missing_total)})\n")
            f.write("\nTop missing (by amount):\n\n")
            for r in sorted(split_cc_missing, key=lambda x: int(x["missing_cents"]), reverse=True)[:10]:
                f.write(
                    f"- bill {r['wave_bill_id']} ({r['invoice_date']}): "
                    f"{r['vendor_raw']} missing ${cents_to_dollars(int(r['missing_cents']))}\n"
                )
        f.write(f"- Over‑settled split CC bills: {len(split_cc_over)}\n")
        if split_cc_over:
            over_total = sum(int(r["over_cents"] or 0) for r in split_cc_over)
            f.write(f"- Total over cents: {over_total} (${cents_to_dollars(over_total)})\n")
            f.write("\nTop over (by amount):\n\n")
            for r in sorted(split_cc_over, key=lambda x: int(x["over_cents"]), reverse=True)[:10]:
                f.write(
                    f"- bill {r['wave_bill_id']} ({r['invoice_date']}): "
                    f"{r['vendor_raw']} over ${cents_to_dollars(int(r['over_cents']))}\n"
                )
        f.write("\n")

        f.write("## Due-from-shareholder drivers (bank debits posted to 2500)\n\n")
        if not due_from_by_reason:
            f.write("- None.\n\n")
        else:
            for reason, cents in sorted(due_from_by_reason.items(), key=lambda kv: abs(kv[1]), reverse=True):
                f.write(f"- {reason}: ${cents_to_dollars(cents)}\n")
            f.write("\n")

        if due_from_non_bank_by_source:
            f.write("Non-bank adjustments impacting `2500` (review as needed):\n\n")
            for src, cents in sorted(due_from_non_bank_by_source.items(), key=lambda kv: abs(kv[1]), reverse=True):
                f.write(f"- {src}: ${cents_to_dollars(cents)}\n")
            f.write("\n")

        f.write("## Remaining conscious decisions / blockers\n\n")
        f.write("- Credit card purchases are intentionally NOT journalized (Wave bills remain the expense source-of-truth).\n")
        f.write("- CC payments clear `2410` (due-to Dwayne); any debit balance in `2410` represents net owed back to the corp (optionally reclass to `2500`).\n")
        inv_codes = ("1200", "1210", "1220", "1230")
        inv_totals: dict[str, int] = {}
        for fy in fys:
            tb = tb_by_fy.get(fy.fy) or []
            by_code = {r.account_code: r for r in tb}
            inv_totals[fy.fy] = sum(int(by_code[c].net_cents) for c in inv_codes if c in by_code)
        if any(v != 0 for v in inv_totals.values()):
            parts = ", ".join(f"{fy.fy} ${cents_to_dollars(inv_totals[fy.fy])}" for fy in fys)
            f.write(f"- Inventory balances posted ({', '.join(inv_codes)}): {parts}.\n")
        else:
            f.write("- Inventory year-end (FY2024 estimate + FY2025 known) is not yet posted to `1200`–`1230`.\n")
        fixed_asset_codes = ("1500", "1510", "1610", "1700", "1710")
        fixed_present = any(any(r.account_code in fixed_asset_codes for r in (tb_by_fy.get(fy.fy) or [])) for fy in fys)
        if fixed_present:
            f.write("- Depreciation/CCA and any fixed-asset rollforward is not yet modeled here.\n")
        else:
            f.write(
                "- No fixed-asset balances detected on Schedule 100, but CCA must be assessed separately via the tax asset register "
                "(`overrides/cca_assets.yml`) and Schedule 8 outputs.\n"
            )

    print("READINESS REPORT BUILT")
    print(f"- out: {out_md}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
